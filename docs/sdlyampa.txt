-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Opis tutaj:
--   <a>https://github.com/rottensunday/Haskell_Projekt_Yampa/blob/master/README.md</a>
@package sdlyampa
@version 1.0.0.0


module Types
type GameSF = SF GameInput GameOutput

-- | Simple wrapper around SDL Texture which also contains texture size
data Texture
Texture :: Texture -> V2 CInt -> Texture

-- | SDL Texture
[texture] :: Texture -> Texture

-- | Texture size
[size] :: Texture -> V2 CInt

-- | Necessary Ball information
data Ball
Ball :: Point V2 Double -> V2 Double -> V2 Double -> Double -> Double -> Ball

-- | Current Ball position
[position] :: Ball -> Point V2 Double

-- | Current Ball velocity
[velocity] :: Ball -> V2 Double

-- | Current Ball acceleration
[acceleration] :: Ball -> V2 Double

-- | Ball radius
[radius] :: Ball -> Double

-- | Power controls how fast our shot power loads
[power] :: Ball -> Double

-- | Type of Game Object
data GameObjType
Player :: GameObjType
Wall :: GameObjType
Spikes :: GameObjType
Goal :: GameObjType

-- | GameObj contains necessary data to draw object: its type and texture
--   coordinates in sheet
data GameObj
GameObj :: GameObjType -> Rectangle CInt -> GameObj
[objType] :: GameObj -> GameObjType
[textureCoords] :: GameObj -> Rectangle CInt

-- | DynamicGameObj contains necessary data ato control dynamic object
--   changes
data DynamicGameObj
DynamicGameObj :: GameObj -> Point V2 Double -> Direction -> Double -> Double -> DynamicGameObj

-- | Data needed to draw object
[gameObj] :: DynamicGameObj -> GameObj

-- | Starting position of object
[startPos] :: DynamicGameObj -> Point V2 Double

-- | Direction of movement
[direction] :: DynamicGameObj -> Direction

-- | Object speed
[speed] :: DynamicGameObj -> Double

-- | Maximum deviation from start position
[limit] :: DynamicGameObj -> Double

-- | Map from tilemap Gids to game objects with corresponding textures
type GidsToObjsMap = Map Word32 GameObj

-- | Map from window positions to gameobjs which should be drawn in
--   corresponding positions
type ObjsMap = Map (Int, Int) GameObj

-- | GameInput is given to main game controller
data GameInput
GameInput :: Bool -> Event () -> Event () -> Point V2 CInt -> Event () -> Integer -> GameInput

-- | Checks whether LMB is pressed
[mPressed] :: GameInput -> Bool

-- | Fires when LMB is pressed
[mEventPressed] :: GameInput -> Event ()

-- | Fires when LMB is released
[mEventReleased] :: GameInput -> Event ()

-- | Mouse position
[mPos] :: GameInput -> Point V2 CInt

-- | Fires when Q is clicked (check whether game should end)
[qClick] :: GameInput -> Event ()

-- | Passes start time to output
[currTimeIn] :: GameInput -> Integer

-- | GameOutput is returned by main game controller
data GameOutput
GameOutput :: Ball -> Bool -> Int -> Bool -> Bool -> Int -> ObjsMap -> Integer -> GameOutput

-- | Output ball info
[ball] :: GameOutput -> Ball

-- | Did we click Q? Then SDL should finish process
[shouldEnd] :: GameOutput -> Bool

-- | Number of player shots
[nShots] :: GameOutput -> Int

-- | Did player finish lvl?
[didWin] :: GameOutput -> Bool

-- | Did player finish the whole game?
[didFinishGame] :: GameOutput -> Bool

-- | Simply pass current level to output
[outLvl] :: GameOutput -> Int

-- | Pass all game objects info
[objsMap] :: GameOutput -> ObjsMap

-- | Pass start time to SDL
[currTimeOut] :: GameOutput -> Integer

-- | GameInfo contains initial game data
data GameInfo
GameInfo :: CInt -> CInt -> CInt -> CInt -> [ObjsMap] -> [[DynamicGameObj]] -> Int -> GameInfo

-- | Window width in pixels
[screenWidth] :: GameInfo -> CInt

-- | Window height in pixels
[screenHeight] :: GameInfo -> CInt

-- | Tile width in pixels
[tileWidth] :: GameInfo -> CInt

-- | Tile height in pixels
[tileHeight] :: GameInfo -> CInt

-- | Loaded static objects map for each map
[staticObjsMap] :: GameInfo -> [ObjsMap]

-- | Loaded dynamic objects collection for each map
[dynamicObjsInfo] :: GameInfo -> [[DynamicGameObj]]

-- | Starting level
[currLvl] :: GameInfo -> Int

-- | Used in collisions. Contains information about side we hit and type of
--   object we collided with on given side
data CollisionEffect
CollisionEffect :: Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> Maybe GameObjType -> CollisionEffect
[leftHitEffect] :: CollisionEffect -> Maybe GameObjType
[rightHitEffect] :: CollisionEffect -> Maybe GameObjType
[upHitEffect] :: CollisionEffect -> Maybe GameObjType
[downHitEffect] :: CollisionEffect -> Maybe GameObjType
[leftUpHitEffect] :: CollisionEffect -> Maybe GameObjType
[rightUpHitEffect] :: CollisionEffect -> Maybe GameObjType
[leftDownHitEffect] :: CollisionEffect -> Maybe GameObjType
[rightDownHitEffect] :: CollisionEffect -> Maybe GameObjType

-- | Which side of a rectangle did we hit?
data HitDir
LeftSide :: HitDir
RightSide :: HitDir
UpSide :: HitDir
DownSide :: HitDir
LeftUpSide :: HitDir
RightUpSide :: HitDir
LeftDownSide :: HitDir
RightDownSide :: HitDir

-- | Direction of dynamic object movement
data Direction
VerticalUp :: Direction
VerticalDown :: Direction
HorizontalLeft :: Direction
HorizontalRight :: Direction
instance GHC.Classes.Eq Types.GameObjType


module Parser

-- | Given GameInput, we get mouse position as a 2D Point
mousePosParser :: SF GameInput (Point V2 Double)
intToDoubleConverter :: SF (Point V2 CInt) (Point V2 Double)

-- | Given GameInput, we check whether Q button was clicked
qClickParser :: SF GameInput (Event ())

-- | Given GameInput, we check whether LMB is pressed
mousePressedParser :: SF GameInput Bool

-- | Given GameInput, we check whether LMB was just pressed
mouseEventPressedParser :: SF GameInput (Event ())

-- | Given GameInput, we check whether LMB was just released
mouseEventReleasedParser :: SF GameInput (Event ())

-- | Given GameInput, we get input time
timeParser :: SF GameInput Integer

-- | Using SDL, we get all important inputs from user and create GameInput
--   object
parseInput :: IO GameInput


module Constants
initScreenWidth :: CInt
initScreenHeight :: CInt
initTileWidth :: CInt
initTileHeight :: CInt
spriteSheetPath :: [Char]
mapsPath :: [Char]
fontPath :: [Char]
windowName :: [Char]
spriteSize :: V2 CInt
ballClip :: Rectangle CInt
wallClip :: Rectangle CInt
spikeClip :: Rectangle CInt
goalClip :: Rectangle CInt
startBall :: Ball
simulationRate :: Double


module ObjectsLoader

-- | Make a GidsToObjsMap for all objects which should be considered when
--   loading map
prepareGidsToObjsMap :: GidsToObjsMap

-- | Load a map from file and initialize ObjsMap
prepareStaticObjsMapSingle :: (CInt, CInt) -> FilePath -> IO ObjsMap

-- | Load all maps from directory and initialize collection of ObjsMap
prepareStaticObjsMap :: (CInt, CInt) -> FilePath -> IO [ObjsMap]

-- | TODO load dynamic game objects. This is NOT finished: we don't load
--   anything from files. Some objects are hard-coded just to show it
--   works.
prepareDynamicObjs :: Int -> IO [[DynamicGameObj]]

-- | Given directory where maps are, this function creates missing scores
--   files in current directory and returns list of paths to files with
--   scores
prepareScoresFiles :: FilePath -> IO [FilePath]


module Utility

-- | This functions filters out all far objects from ObjsMap map
filterFarObjects :: GameInfo -> ObjsMap -> Point V2 Int -> ObjsMap

-- | head which returns Nothing on empty list
headMaybe :: [a] -> Maybe a


module BallController

-- | ballController is responsible for controlling ball state. It's one big
--   SF which uses many other SFs defined in this module.
ballController :: Ball -> GameInfo -> SF (GameInput, ObjsMap) GameOutput

-- | Our clicks should only modify velocity, based on ball position, player
--   position and power given
clickSpeedModifier :: SF (Event (Point V2 Double, Point V2 Double, Double)) (V2 Double)

-- | hitSAModifier is a Hit Speed Acceleration Modifier. On collision we
--   will change speed and acceleration. For example, when we're rolling
--   and friction works and we hit a wall, friction direction should
--   change.
hitSAModifier :: SF (Event ((GameObjType, HitDir), (V2 Double, V2 Double, Bool))) (V2 Double, V2 Double)

-- | powerCalc is supposed to calculate power of ball shot. it just applies
--   acc value to integral and switches, so we go back and forward between
--   0 and 100 power value
powerCalc :: Double -> Double -> SF Bool Double

-- | computePrevVals updates our list of 3 recent positions
computePrevVals :: SF (Double, Double, [V2 Double]) [V2 Double]

-- | getVA this is the most important SF: it is concerned with velocity.
--   Our acceleration values are modified discretely, and our position
--   value is based only on velocity. Velocity values are changed in
--   continuous and discrete manner (it changes all the time based on
--   acceleration, and it may change according to events). Discrete changes
--   are implemented as rSwitch in ballController, and continuous changes
--   are implemented here.
getVA :: Ball -> SF (V2 Double, V2 Double, Bool) (V2 Double, V2 Double)

-- | Check whether we collided with spikes
verifyLoseCondition :: SF (Event (GameObjType, HitDir)) (Event ())

-- | Check whether we collided with goal
verifyWinCondition :: SF (Event (GameObjType, HitDir)) (Event ())

-- | This SF filters far objects from ObjsMap given in input
filterFarObjectsSF :: GameInfo -> SF (ObjsMap, Point V2 Int) ObjsMap

-- | collisionCalculator processes all objects from given ObjsMap and
--   checks every edge for a collision with current player position
collisionCalculator :: (Int, Int) -> SF (ObjsMap, Point V2 Double, Double) CollisionEffect

-- | collisionChecker is responsible for generating informations on
--   collisions. It uses collisionCalculator to calculate collisions.
--   Beside generating event on collision, it gives us continuous info
--   whether we're rolling
collisionChecker :: GameInfo -> SF (Point V2 Double, V2 Double, Double, ObjsMap) (Event (GameObjType, HitDir), Bool)


module GameController

-- | This simple controller is used to control the state of dynamic game
--   objects beside the player. These objects have very basic
--   functionanlity: initial position, positon limit, directory and speed.
--   They just slide back and forward.
dynamicObjectController :: DynamicGameObj -> Double -> SF () (V2 Double, GameObj)

-- | This controller is controlling state of the whole game. For now it
--   just gets position of all dynamic objects and uses ballController with
--   given objects as an input to produce output
gameController :: Ball -> GameInfo -> GameSF


module SDLWrapper

-- | Load a texture from file
loadTexture :: Renderer -> FilePath -> IO Texture

-- | Create a texture with string (using SDL.Font)
loadTextTexture :: Renderer -> Font -> String -> V4 Word8 -> IO Texture

-- | Render a texture on window
renderTexture :: Renderer -> Texture -> Point V2 CInt -> Maybe (Rectangle CInt) -> IO ()


module Game

-- | Main is supposed to initialize all IO (create SDL Window, create
--   Renderer, load maps and scores from files) and then start reactimate
--   loop
main :: IO ()

-- | appLoop is responsible for displaying game state with SDL and managing
--   IO when needed (for example: saving score)
appLoop :: Renderer -> Texture -> [[Int]] -> [FilePath] -> [ObjsMap] -> Font -> GameOutput -> IO Bool
